var Gateway   = require('./gateway'),
    SSDP      = require('./ssdp'),
    xml2js    = require('xml2js'),
    needle    = require('needle'),
    url_parse = require('url').parse,
    utils     = require('./utils'),
    inspect   = require('util').inspect;

var gw,
    private_ip,
    search_timeout = 5000;

var debug = function(str, obj) {
  if (process.env.DEBUG)
    console.log(str) || obj && console.log(obj)
}

var matches = function(obj, conditions) {
  for (var key in obj) {
    if (conditions[key] && conditions[key] == obj[key])
      return true;
  }
  return false;
}

// xml2js.parseString() with callback was giving 'unspecified "error" event'
// so we returned to the old emitter-style interface
var parseXML = function(str, cb) {

  var returned = 0;

  var done = function(err, res) {
    if (returned++) return;
    cb(err, res);
  }

  var parser = new xml2js.Parser({ explicitArray: false });

  parser.addListener('error', done);
  parser.addListener('end', function(result) { done(null, result)  });
  parser.parseString(str);
}

var parseResponse = function(str) {
  var obj = {};
  str.toString().split('\n').forEach(function(line) {
    var match = line.match(/:(.+)/);
    if (!match || !match[1]) return;

    obj[line.split(':')[0].toLowerCase()] = match[1];
  })
  return obj;
}

var parseMapping = function(xml, type_key, cb) {
  if (!xml || xml.toString().trim() == '')
    return cb(new Error('Empty XML!'));

  parseXML(xml, function(err, res) {
    if (err) return cb(err);

    var mapping,
        prefixes = ['u:', 'm:'], // some routers use m: as prefix, unlike most
        envelope = res['s:Envelope'];

    var soap_body = envelope && envelope['s:Body'];
    if (!soap_body)
      return cb(new Error("Couldn't find soap body in: " + inspect(res)));

    for (var i in prefixes) {
      var type = prefixes[i] + type_key;

      if (!soap_body[type])
        continue;

      delete(soap_body[type]['$']);
      mapping = soap_body[type];
    }

    if (mapping)
      cb(null, mapping);
    else
      cb(new Error('Not found.'));
  })
}

var getPrivateIP = function(cb) {
  if (private_ip)
    return cb(null, private_ip);

  utils.get_private_ips(function(err, ips) {
    if (err || !ips[0])
      return cb(err || new Error('Unable to find private IP.'));
    else if (!gw)
      return cb(null, ips[0])

    var gw_base = gw.host.match(/(.*)\.(\d+)/)[1];

    var active = ips.filter(function(ip) {
      if (ip.match(/(.*)\.(\d+)/)[1].indexOf(gw_base) != -1)
        return ip;
    })[0];

    cb(null, active);
  });
}

var getControlURL = function(url, cb){

  var find_in_xml = function(xml, serviceType) {
    var res = utils.find_by_key(xml, 'controlURL', function(obj) {
      return obj.serviceType && obj.serviceType.match(serviceType)
    });

    return (res);
  }

  needle.get(url, { parse: false }, function(err, resp, body) {
    if (err) return cb(err);

    xml2js.parseString(body.toString(), { explicitArray: false }, function(err, xml) {
      if (err) return cb(err);

      var url = find_in_xml(xml, 'WANIPConnection:1');
      if (!url[0]) url = find_in_xml(xml, 'Connection:1');

      if (url && url[0])
        cb(null, url[0]);
      else
        cb(new Error('Unable to find controlURL in gateway response.'))
    })
  })
}

var findGateway = function(cb) {

  var timer,
      found,
      returned,
      client = new SSDP;

  var finish = function(err) {
    if (returned) return;
    clearTimeout(timer);
    client.close();
    cb(err)
    returned = true;
  }

  client.on('response', function(msg, rinfo) {
    debug(rinfo, msg.toString());
    if (found) return;
    found = true;

    var data = parseResponse(msg);

    if (!data.location)
      return finish(new Error('Unable to get query URL for gateway.'));

    var server = url_parse(data.location);
    debug('Gateway responded! Querying at ' + server.host);

    getControlURL(data.location, function(err, path) {
      if (err || !path)
        return finish(err ||  new Error('Could not find gateway control URL.'));

      debug('Initializing gateway: ' + rinfo.address + ':' + server.port + path);

      gw = new Gateway(server.port, rinfo.address, path);
      gw.located_at = new Date();

      finish();
    });
  });

  client.on('error', finish);

  var keys = [
    'urn:schemas-upnp-org:device:InternetGatewayDevice:1',
    'urn:schemas-upnp-org:service:WANPPPConnection:1',
    'urn:schemas-upnp-org:service:WANIPConnection:1'
  ]

  function sendReq(i) {
    if (found || !keys[i]) return;

    debug('Searching ' + keys[i]);
    client.search(keys[i]);

    setTimeout(function() { sendReq(i+1) }, 50);
  }

  sendReq(0);

  timer = setTimeout(function() {
    finish(new Error('Could not locate gateway on time.'))
  }, search_timeout);

}

exports.list = function(cb) {
  findGateway(function(err) {
    if (err) return cb(err);

    var error,
        returned,
        count = 0,
        list = [],
        type = 'GetGenericPortMappingEntryResponse';

    var done = function(err) {
      if (err) error = err;
      // cb(err, list);
      cb(null, list);
    }

    var get = function(i) {
      if (error) return;

      gw.getMapping(i, function(err, res) {
        if (err || !res)
          return done(err || new Error('No response received.'));

        parseMapping(res.body, type, function(err, obj) {
          if (err) return done(err);

          list.push(obj);
          get(++i);
        });
      });

    }

    get(0)
  })
}

/*
exports.find = function(opts, cb) {
  var found = null;

  exports.list(function(err, list) {
    if (err) return cb(err);
    if (list.length == 0) return cb();

    list.forEach(function(mapping) {
      if (matches(mapping, opts))
        found = mapping;
    })

    cb(null, found);
  })
}
*/

exports.mine = function(cb) {
  var mine = [];

  exports.list(function(err, list) {
    if (err) return cb(err);

    getPrivateIP(function(err, ip) {
      if (err) return cb(err);

      list.forEach(function(mapping) {

        if (mapping.NewInternalClient == ip)
          mine.push(mapping);
      });

      cb(null, mine);
    });

  });
};

exports.exists = function(opts, cb) {
  findGateway(function(err) {
    if (err) return cb(err);

    gw.findMapping(opts, function(err, resp) {
      if (!resp)
        return cb(err || new Error('No response received.'));

      var type = 'GetSpecificPortMappingEntryResponse';
      parseMapping(resp.body, type, function(err, obj) {
        if (!obj) return cb();

        // check whether this mapping points to me or not
        getPrivateIP(function(err, ip) {
          obj.mine = (ip && obj.NewInternalClient == ip);
          cb(null, obj);
        });

      });
    });
  })
}

exports.map = function(opts, cb) {
  exports.exists(opts, function(err, mapping) {
    if (err || mapping) return cb(err || new Error('Already mapped.'));

    // at this point we should have a valid gateway, so dont findGateway again.
    getPrivateIP(function(err, private_ip) {
      if (err) return cb(err);

      opts.ip = private_ip;
      gw.addPortMapping(opts, cb);
    })
  });
}

exports.unmap = function(opts, cb) {
  findGateway(function(err) {
    if (err) return cb(err);
    gw.deletePortMapping(opts, cb);
  })
}

exports.public_ip = function(cb) {
  findGateway(function(err) {
    if (err) return cb(err);

    gw.getExternalIPAddress(function(err, resp) {
      if (err) return cb(err);

      var matches = resp.body.match(/<NewExternalIPAddress>([^<]+)</);
      if (matches && matches[1])
        return cb(null, matches[1]);
      else
        return cb(new Error('Unable to get IP address from response: ' + resp.body.toString()))
    });
  })
}

exports.gateway_ip = function(cb) {
  findGateway(function(err) {
    if (err) return cb(err);

    cb(null, gw.host);
  })
}
